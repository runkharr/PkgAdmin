#! /usr/bin/perl
##
## $Id$
## Author: Boris Jakubith
## E-Mail: runkharr@googlemail.com
## Copyright: (c) 2010, Boris Jakubith <runkharr@googlemail.com>
## License: GPL (version 2)
##
## Debian-changelog manipulator ...
##
eval 'exec perl -wS $0 ${1+"$@"}'
    if $running_under_some_shell;

# $Id$
#
# Author: Boris Jakubith
# E-Mail: fbj@blinx.de
# Copyright: (c) 2008, Boris Jakubith <fbj@blinx.de>
# License: GPL (version 2)
#
# Small Perl-script for maintaining the debian/changelog file ...
#

use IO::Handle;
use POSIX qw(strftime setlocale LC_ALL LC_CTYPE);

sub ppsplit ($;$);
sub edit ($);
sub nl_strftime (@);
sub read_control ($);
# sub print_r (*$;$);

my ($prog, $ppath) = ppsplit ($0);
(my $top = $ppath) =~ s(/admin$)();
my $adm = "$top/admin";

my $MAXCLL = 72;

my $debdir = "$top/debian";
my $changelog = 'changelog';
my $clpath = "$debdir/$changelog";
my $control = "$debdir/control";

my $get_maintainer_only = undef;
while (@ARGV && ($_ = $ARGV[$[], /^-/)) {
    shift; last if ($_ eq '--');
    if (/^-m$|^--maintainer-only$/) {
	$get_maintainer_only = 1;
    } else {
	print STDERR "$prog: invalid option `$_´\n"; exit (64);
    }
}

if (@ARGV) {
    $clpath = shift;
    unless (-f $clpath) {
	die "$prog: argument '$clpath' is no regular file\n";
    }
    ($changelog = $clpath) =~ s(^.*/)();
    ($debdir = $clpath) =~ s(/[^/]*$)();
    $control = "$debdir/control";
    unless ($debdir =~ m#/debian$|^debian$#) {
	die "$prog: last path-element of '$debdir' is not 'debian'\n";
    }
}

unless (-d $debdir) {
    die "$prog: '$debdir'-directory not found. Did you start me in right".
	" directory?\n";
}

open CL, "<$clpath" or
    die "$prog: attempt to open '$clpath' failed - $!\n";

@CL = (); @e = (); $pn = undef; $pv = undef; $pxd = undef;
while (<CL>) {
    chomp; s/\r$//;
    if (/^([\w-]+) \((.+?)\) (\w+; urgency=.+)/) {
	unless (defined $pn) { $pn = $1; $pv = $2; $pxd = $3; }
	if (@e) { push @CL, [ @e ]; @e = (); }
    }
    push @e, $_;
}
if (@e) { push @CL, [ @e ]; @e = (); }
close CL;

@e = @{$CL[$[]};

# Try to retrieve the maintainer in three steps ...
#
# Step 1: Try to read it from a file `MAINTAINERS' in the top-level directory
#         of the source-tree ...
#
my $maintainer = undef;
if (open MAINTAINER, "<$top/MAINTAINER") {
    $_ = <MAINTAINER>; chomp; s/\r$//; s/^\s+//; s/\s+$//;
    if (/^([^\s]+ )+<[^>\@]+\@[^>]+>$/) { $maintainer = $_; }
    close MAINTAINER;
}
#
#  Step 2: Try to extract it from the `Source'-section of `debian/control' ...
#
unless (defined $maintainer) {
    my ($err, $CTL) = read_control ($control);
    if (!$err && exists $CTL->{source}{maintainer}) {
	$maintainer = $CTL->{source}{maintainer};
    }
}
#
#  Step 3: Try to extract it from the first section of `debian/changelog' ...
#
unless (defined $maintainer) {
    for $_ (@e) {
	if (/^ -- (([^\s]+ )+<[^>]+>)  /) { $maintiner = $1; last; }
    }
}

unless (defined $maintainer) {
    die "$prog: attempt to detect the package maintainer failed\n";
}

if ($get_maintainer_only) {
    print "$maintainer\n"; exit 0;
}

open VERSION, "<$top/VERSION" or
    die "$prog: attempt to get the version number failed - $!\n";
$_ = <VERSION>; chomp; s/\r$//; close VERSION;
$version = $_;

($v, $dv) = ($pv =~ /^(.+)(?:-([^-]+))?$/);
if ($v eq $version) {
    if ((length $dv) == 0) { exit 0; }
    my $af = STDIN->autoflush (1);
    for (;;) {
	print "The program version and the last entry in the debian changelog".
	      " match.\nDo you want to change the debian release number".
	      " (current = $dv) instead ? ";
	$_ = <STDIN>; chomp; s/\r$//; s/^\s+//; s/\s+$//;
    last if (/^y(es)?$/ || /^no?$/);
	print "Please answer only with y[es] or n[o]!\n\n";
    }
    if (/^no?$/) { print "Ok ... bye\n"; exit 0; }
    for (;;) {
	print "Please enter the debian release number: ";
	$_ = <STDIN>; chomp; s/\r$//; s/^\s+//; s/\s+$//;
    last if (/^[^\s-]+$/);
	print "Wrong format. Please retry!\n\n";
    }
    if ($dv eq $_) {
	print STDERR "$prog: The debian release number equals that of the".
		     " last entry in the\n".(' ' x length $prog)."  $changelog".
		     " file. I assume you don't really want to change the\n".
		     (' ' x length $prog)."  $clpath.\n";
	exit 0;
    }
    $dv = $_;
}
$tf = "$debdir/tx-$$.in";
open TX, ">$tf" or
    die "$prog: attempt to prepare editing failed - $!\n";
$etext = <<EOT;

##DELETE from here
# Please enter a text describing the new version. This text is later inserted
# as a new changelog entry in the form
# $pn ($version@{[$dv ? '-' : '']}$dv) $pxd
#
#   * <your text>
#
#  -- $maintainer  «current date (rfc822)»
#
# Each empty line in your text leads to a new line starting with '*' ...
EOT
print TX $etext;
close TX;

$rc = edit ($tf);
unless (defined $rc) {
    $err = "$!"; unlink $tf;
    die "$prog: editing '$tf' failed - $err\n";
}

if ($rc) {
    print STDERR "$prog: WARNING! The editor returned a non-zero exit code\n";
}

open TX, "<$tf" or
    die "$prog: attempt to read the description failed - $!\n";

@e = ("$pn ($version@{[$dv ? '-' : '']}$dv) $pxd", ""); @t = ();
$e = '';
while (<TX>) {
    chomp; s/\r$//;
last if (/^##DELETE/);
    s/^\s+//; s/\s+$//;
    if ($_ eq '') {
	if ($e ne '') { $e =~ s/^ //; push @t, $e; $e = ''; }
	next;
    }
    $e .= ' '.$_;
}
$e =~ s/^ //;
push @t, $e if ($e ne '');
close TX; unlink $tf;

unless (@t) {
    print STDERR "$prog: you inserted no non-empty text, so i assume".
		 " you don't want to\n".(' ' x length $prog).
		 "  change the $changelog.\n";
    exit 0;
}

for $t (@t) {
    @w = split /\s+/, $t;
    $l = '  *';
    while (@w) {
	$w = shift @w;
	if (length ("$l $w") < $MAXCLL) {
	    $l .= " $w";
	} else {
	    push @e, $l; $l = "    $w";
	}
    }
    if (length ($l) > 3) { push @e, $l; }
}

$ts = nl_strftime ('%a, %e %b %Y %H:%M:%S %z', (localtime (time ())));
push @e, "", " -- $maintainer  $ts", "";
unshift @CL, [ @e ];

unlink "$clpath.OLD";
rename $clpath, "$clpath.OLD" or
    die "$prog: attempt to save current '$clpath' failed - $!\n";
unless (open CL, ">$clpath") {
    $ec = "$!\n";
    unlink "$clpath";
    rename "$clpath.OLD", $clpath;
    die "$prog: attempt to write new '$clpath' failed - $!\n";
}
for $e (@CL) {
    for $_ (@{$e}) { print CL "$_\n"; }
}
close CL;

unlink "$clpath.OLD";

exit 0;

sub ppsplit ($;$) {
    use Cwd;
    my ($pp, $pdel) = @_;
    $pdel = '/' unless ($pdel);
    my @pp = split /$pdel/, $pp;
    my $pn = pop @pp;
    unless (@pp && (length $pp[$[]) == 0) {
	my $cwd = cwd ();
#	my $cwd = `pwd`; chomp $cwd; $cwd =~ s/\r$//;
	unshift @pp, (split /$pdel/, $cwd);
    }
    my @res = ();
    while (@pp) {
	my $x = shift @pp;
	if ($x eq '..') {
	    pop @res if (@res > 1);
	} elsif ($x ne '.') {
	    push @res, $x;
	}
    }
    ($pn, join ($pdel, @res))
}

sub check_prog ($) {
    my $p = shift;
    for my $path (qw(/bin /usr/bin /usr/local/bin)) {
	my $pp = "$path/$p";
	return $pp if (-f $pp && -x $pp);
    }
    undef
}

sub edit ($) {
    my ($file) = @_;
    my $editor;
    if (exists $ENV{EDITOR} && -f $ENV{EDITOR} && -x $ENV{EDITOR}) {
	$editor = $ENV{EDITOR};
    }
    $editor = check_prog ('editor') unless (defined $editor);
    $editor = check_prog ('le') unless (defined $editor);
    $editor = check_prog ('vim') unless (defined $editor);
    $editor = check_prog ('vi') unless (defined $editor);
    $editor = check_prog ('nano') unless (defined $editor);
    $editor = check_prog ('editor') unless (defined $editor);
    unless (defined $editor) {
	print STDERR "$prog: no editor found\n"; undef
    } else {
	(system $editor, $file)
    }
}

sub nl_strftime (@) {
    my @args = @_;
    die "$prog: Not enough arguments for main::nl_strftime\n" if (@args < 7);
    while (@args < 10) { push @args, -1; }
    my $lc = setlocale (LC_ALL); setlocale (LC_ALL, "C");
    my $res = strftime (@args);
    setlocale ($lc);
    $res
}

sub read_control ($) {
    my ($control) = @_;
    my ($lastitem, $line, $lc, @FILE, %SECTION, %FILE, $err, $section);
    my ($secname, $item);
    $lastitem = undef; $line = ''; $lc = 0; %SECTION = (); $err = undef;
    $section = 0;
    if ((open my $cfh, '<', $control)) {
	while (<$cfh>) {
	    chomp; s/\r$//; ++$lc;
	    if ($_ eq '') { # (/^\s*$/) {	#}
		## End of a section ...
		if ($lastitem) {
		    if (exists $SECTION{$lastitem}) {
			print STDERR "ERROR($lc): ambiguous '$lastitem'".
				     " - skipping ...\n";
		    } else {
			$SECTION{$lastitem} = $line;
		    }
		}
		if (%SECTION) { ++$section; push @FILE, +{ %SECTION }; }
		%SECTION = (); $lastitem = undef; $line = '';
		next;
	    }
	    if (/^\s/) {
		## Line continuation (from previous line(s)) ...
		if (! $lastitem) {
		    print STDERR "ERROR($lc): invalid '$control' file".
				 " - aborting ...\n";
		    $err = 1; last;
		}
		$line .= $_; next;
	    }
	    if (/^([A-Za-z]\w*(-[A-Za-z]\w+)*)\s*:\s*(.*)/) {
		## New item ...
		my ($item, $val) = ($1, $3);
		if ($lastitem) {
		    ## Try to store the last open line ...
		    if (exists $SECTION{$lastitem}) {
			print STDERR "ERROR($lc): ambiguous '$lastitem'".
				     " - skipping ...\n";
			next;
		    }
		    $SECTION{$lastitem} = $line;
		}
		$lastitem = lc $1; $line = $3;
	    }
	}
	close $cfh;
    }
    return ($err, undef) if ($err);
    if ($lastitem) {
	if (exists $SECTION{$lastitem}) {
	    print STDERR "ERROR($lc): ambiguous '$lastitem' - skipping ...\n";
	} else {
	    $SECTION{$lastitem} = $line;
	}
    }
    if (%SECTION) { ++$section; push @FILE, { %SECTION }; }
    %FILE = (); $item = 'source'; $lc = 0;
    for $section (@FILE) {
	++$lc; $secname = $section->{$item};
	unless (defined ($secname)) {
	    print STDERR "ERROR: Section #$lc contains no identification!\n";
	    next;
	}
	if (exists $FILE{$secname}) {
	    print STDERR "ERROR: Section #${lc}'s identification".
			 " is ambiguous!\n";
	    next;
	}
	if ($item eq 'source') {
	    $FILE{source} = $section;
	} else {
	    $FILE{$secname} = $section;
	}
	$item = 'package';
    }
    +(0, { %FILE })
}

# sub print_r (*$;$) {
#     local (*FH) = (shift @_);
#     my ($data, $sw) = @_;
#     my ($k, $v);
#     $sw = 0 unless (defined $sw);
#     if ((ref $data) eq '') {
# 	print FH "$data\n";
#     } elsif ((ref $data) eq 'HASH') {
# 	print FH "{\n";
# 	for $k (keys %{$data}) {
# 	    print FH ' ' x ($sw + 4), "$k => ";
# 	    print_r (FH, $data->{$k}, $sw + 4);
# 	}
# 	print FH ' ' x $sw, "}\n";
#     } elsif ((ref $data) eq 'ARRAY') {
# 	print FH "[\n";
# 	for $k (0 .. $#{$data}) {
# 	    print FH ' ' x ($sw + 4), "[$k] => ";
# 	    print_r (FH, $data->[$k], $sw + 4);
# 	}
# 	print FH ' ' x $sw, "]\n";
#     } elsif ((ref $data) eq 'SCALAR') {
# 	print FH '\ '.${$data}."\n";
#     } elsif (UNIVERSAL::isa ($data, 'HASH')) {
# 	print FH (ref $data)." = {\n";
# 	for $k (keys %{$data}) {
# 	    print FH ' ' x ($sw + 4), "$k => ";
# 	    print_r (FH, $data->{$k}, $sw + 4);
# 	}
# 	print FH ' ' x $sw, "}\n";
#     } elsif (UNIVERSAL::isa ($data, 'ARRAY')) {
# 	print FH (ref $data)." = [\n";
# 	for $k (0 .. $#{$data}) {
# 	    print FH ' ' x ($sw + 4), "[$k] => ";
# 	    print_r (FH, $data->[$k], $sw + 4);
# 	}
# 	print FH ' ' x $sw, "]\n";
#     } else {
# 	print FH "$data\n";
#     }
# }
