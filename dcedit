#! /usr/bin/perl
##
## $Id$
## Author: Boris Jakubith
## E-Mail: runkharr@googlemail.com
## Copyright: (c) 2010, Boris Jakubith <runkharr@googlemail.com>
## License: GPL (version 2)
##
## Debian-changelog manipulator ...
##
eval 'exec perl -wS $0 ${1+"$@"}'
    if $running_under_some_shell;

# $Id$
#
# Author: Boris Jakubith
# E-Mail: fbj@blinx.de
# Copyright: (c) 2008, Boris Jakubith <fbj@blinx.de>
# License: GPL (version 2)
#
# Small Perl-script for maintaining the debian/changelog file ...
#

use strict; 

use IO::Handle;
use POSIX qw(strftime setlocale LC_ALL LC_CTYPE);

sub ppsplit :prototype($;$);
sub edit :prototype($);
sub nl_strftime :prototype(@);
sub read_control :prototype($);
sub prompt :prototype($;&);
sub check_debrelease :prototype($);
sub empty :prototype(\[$@%]);
sub check_eof :prototype(;$_);

my ($prog, $ppath) = ppsplit ($0);
(my $top = $ppath) =~ s(/admin$)();
my $adm = "$top/admin";

my $MAXCLL = 72;

my $debdir = "$top/debian";
my $changelog = 'changelog';
my $clpath = "$debdir/$changelog";
my $control = "$debdir/control";

my $get_maintainer_only = undef;
while (@ARGV && ($_ = $ARGV[$[], /^-/)) {
    shift; last if ($_ eq '--');
    if (/^-m$|^--maintainer-only$/) {
	$get_maintainer_only = 1;
    } else {
	print STDERR "$prog: invalid option `$_´\n"; exit (64);
    }
}

if (@ARGV) {
    $clpath = shift;
    unless (-f $clpath) {
	die "$prog: argument '$clpath' is no regular file\n";
    }
    ($changelog = $clpath) =~ s(^.*/)();
    ($debdir = $clpath) =~ s(/[^/]*$)();
    $control = "$debdir/control";
    unless ($debdir =~ m#/debian$|^debian$#) {
	die "$prog: last path-element of '$debdir' is not 'debian'\n";
    }
}

unless (-d $debdir) {
    die "$prog: '$debdir'-directory not found. Did you start me in right".
	" directory?\n";
}

prompt ('Do you really want to modify the `debian/changelog` file?') or
    exit 1;

open *CL, '<', $clpath or
    die "$prog: attempt to open '$clpath' failed - $!\n";

my (@CL, @e, $pn, $pv, $pxd);
while (<CL>) {
    chomp; s/\r$//;
    if (/^([\w-]+) \((.+?)\) (\w+; urgency=.+)/) {
	unless (defined $pn) { $pn = $1; $pv = $2; $pxd = $3; }
	if (@e) { push @CL, [ @e ]; @e = (); }
    }
    push @e, $_;
}
if (@e) { push @CL, [ @e ]; @e = (); }
close CL;

@e = @{$CL[$[]};

# Try to retrieve the maintainer in three steps ...
#
# Step 1: Try to read it from a file `MAINTAINERS' in the top-level directory
#         of the source-tree ...
#
my $maintainer = undef;
if (open *MAINTAINER, '<', "$top/MAINTAINER") {
    $_ = <MAINTAINER>; chomp; s/\r$//; s/^\s+//; s/\s+$//;
    if (/^([^\s]+ )+<[^>\@]+\@[^>]+>$/) { $maintainer = $_; }
    close MAINTAINER;
}
#
#  Step 2: Try to extract it from the `Source'-section of `debian/control' ...
#
unless (defined $maintainer) {
    my ($err, $CTL) = read_control ($control);
    if (!$err && exists $CTL->{source}{maintainer}) {
	$maintainer = $CTL->{source}{maintainer};
    }
}
#
#  Step 3: Try to extract it from the first section of `debian/changelog' ...
#
unless (defined $maintainer) {
    foreach (@e) {
	if (/^ -- (([^\s]+ )+<[^>]+>)  /) { $maintainer = $1; last; }
    }
}

unless (defined $maintainer) {
    die "$prog: attempt to detect the package maintainer failed\n";
}

if ($get_maintainer_only) {
    print "$maintainer\n"; exit 0;
}

my $version = do {
    open my $ver_fh, '<', "$top/VERSION" or
	die "$prog: attempt to get the version number failed - $!\n";
    chomp ($_ = <$ver_fh>); chomp; s/\r$//; close $ver_fh;
    $_;
};

my ($v, $dv) = ($pv =~ /^(.+?)(?:-(.+))?$/);

print "\nThe current debian version number (<version>-<release>) is: $v-$dv\n";
if ($v eq $version) {
    if (empty $dv) { exit 0; }
    my $af = STDIN->autoflush (1);
    my $tf = print "The program version and the last entry in the debian".
		   " changelog match.\n";
    my $tf = prompt "Do you want to change the debian release number ($dv)".
		    " instead?";
    unless ($tf) { print "Nothing to do ... bye.\n"; exit 0; }
    print "\n";
    $_ = prompt "Debian release number ($dv) [ENTER for no change]:",
		\&check_debrelease;
    check_eof;
    $_ = $dv if (empty $_);
    if ($dv eq $_) {
	print "\nThe debian release remains unchanged, so no change on the".
	      " `debian/changelog`\nfile is necessary. Bye.\n";
	exit 0;
    }
    $dv = $_;
} else {
    print "\nThe new version number is: $version. It was extracted from the".
	  " `VERSION` file.\nNow, you may change the debian release number.".
	  "\n\n";
    $_ = prompt 'Debian release number ($dv) [ENTER for no change]:',
		\&check_debrelease;
    check_eof;
    if (empty $_) {
	print "OK, the debian release number remains unchanged. It is: $dv\n";
    } else {
	$dv = $_;
    }
}

my $tf = "$debdir/tx-$$.in";
open *TX, '>', $tf or
    die "$prog: attempt to prepare editing failed - $!\n";
my $etext = <<EOT;

##DELETE from here
# Please enter a text describing the new version. This text is later inserted
# as a new changelog entry in the form
# $pn ($version@{[$dv ? '-' : '']}$dv) $pxd
#
#   * <your text>
#
#  -- $maintainer  «current date (rfc822)»
#
# Each empty line in your text leads to a new line starting with '*' ...
EOT
print TX $etext;
close TX;

my $rc = edit ($tf);
unless (defined $rc) {
    my $err = "$!"; unlink $tf;
    die "$prog: editing '$tf' failed - $err\n";
}

if ($rc) {
    print STDERR "$prog: WARNING! The editor returned a non-zero exit code\n";
}

open *TX, '<', $tf or
    die "$prog: attempt to read the description failed - $!\n";

@e = ("$pn ($version@{[$dv ? '-' : '']}$dv) $pxd", ""); my @t = ();
my $e = '';
while (<TX>) {
    chomp; s/\r$//;
last if (/^##DELETE/);
    s/^\s+//; s/\s+$//;
    if ($_ eq '') {
	if ($e ne '') { $e =~ s/^ //; push @t, $e; $e = ''; }
	next;
    }
    $e .= ' '.$_;
}
$e =~ s/^ //;
push @t, $e if ($e ne '');
close TX; unlink $tf;

unless (@t) {
    print STDERR "$prog: you inserted no non-empty text, so i assume".
		 " you don't want to\n".(' ' x length $prog).
		 "  change the $changelog.\n";
    exit 0;
}

for my $t (@t) {
    my @w = split /\s+/, $t;
    my $l = '  *';
    while (@w) {
	my $w = shift @w;
	if (length ("$l $w") < $MAXCLL) {
	    $l .= " $w";
	} else {
	    push @e, $l; $l = "    $w";
	}
    }
    if (length ($l) > 3) { push @e, $l; }
}

my $ts = nl_strftime ('%a, %e %b %Y %H:%M:%S %z', (localtime (time ())));
push @e, "", " -- $maintainer  $ts", "";
unshift @CL, [ @e ];

unlink "$clpath.OLD";
rename $clpath, "$clpath.OLD" or
    die "$prog: attempt to save current '$clpath' failed - $!\n";
unless (open *CL, '>', $clpath) {
    my $ec = "$!\n";
    unlink "$clpath";
    rename "$clpath.OLD", $clpath;
    die "$prog: attempt to write new '$clpath' failed - $!\n";
}
for my $e (@CL) {
    foreach (@{$e}) { print CL "$_\n"; }
}
close CL;

unlink "$clpath.OLD";

exit 0;

sub ppsplit :prototype($;$) {
    use Cwd;
    my ($pp, $pdel) = @_;
    $pdel = '/' unless ($pdel);
    my @pp = split /$pdel/, $pp;
    my $pn = pop @pp;
    unless (@pp && empty $pp[$[]) {
	my $cwd = cwd ();
#	my $cwd = `pwd`; chomp $cwd; $cwd =~ s/\r$//;
	unshift @pp, (split /$pdel/, $cwd);
    }
    my @res = ();
    while (@pp) {
	my $x = shift @pp;
	if ($x eq '..') {
	    pop @res if (@res > 1);
	} elsif ($x ne '.') {
	    push @res, $x;
	}
    }
    ($pn, join ($pdel, @res))
}

sub check_prog :prototype($) {
    my $p = shift;
    for my $path (qw(/bin /usr/bin /usr/local/bin)) {
	my $pp = "$path/$p";
	return $pp if (-f $pp && -x $pp);
    }
    undef
}

sub edit :prototype($) {
    my ($file) = @_;
    my $editor;
    if (exists $ENV{EDITOR} && -f $ENV{EDITOR} && -x $ENV{EDITOR}) {
	$editor = $ENV{EDITOR};
    }
    $editor = check_prog ('editor') unless (defined $editor);
    $editor = check_prog ('le') unless (defined $editor);
    $editor = check_prog ('vim') unless (defined $editor);
    $editor = check_prog ('vi') unless (defined $editor);
    $editor = check_prog ('nano') unless (defined $editor);
    $editor = check_prog ('editor') unless (defined $editor);
    unless (defined $editor) {
	print STDERR "$prog: no editor found\n"; undef
    } else {
	(system $editor, $file)
    }
}

sub nl_strftime :prototype(@) {
    my @args = @_;
    die "$prog: Not enough arguments for main::nl_strftime\n" if (@args < 7);
    while (@args < 10) { push @args, -1; }
    my $lc = setlocale (LC_ALL); setlocale (LC_ALL, "C");
    my $res = strftime (@args);
    setlocale ($lc);
    $res
}

sub read_control :prototype($) {
    my ($control) = @_;
    my ($lastitem, $line, $lc, @FILE, %SECTION, %FILE, $err, $section);
    my ($secname, $item);
    $lastitem = undef; $line = ''; $lc = 0; %SECTION = (); $err = undef;
    $section = 0;
    if ((open my $cfh, '<', $control)) {
	while (<$cfh>) {
	    chomp; s/\r$//; ++$lc;
	    if ($_ eq '') { # (/^\s*$/) {	#}
		## End of a section ...
		if ($lastitem) {
		    if (exists $SECTION{$lastitem}) {
			print STDERR "ERROR($lc): ambiguous '$lastitem'".
				     " - skipping ...\n";
		    } else {
			$SECTION{$lastitem} = $line;
		    }
		}
		if (%SECTION) { ++$section; push @FILE, +{ %SECTION }; }
		%SECTION = (); $lastitem = undef; $line = '';
		next;
	    }
	    if (/^\s/) {
		## Line continuation (from previous line(s)) ...
		if (! $lastitem) {
		    print STDERR "ERROR($lc): invalid '$control' file".
				 " - aborting ...\n";
		    $err = 1; last;
		}
		$line .= $_; next;
	    }
	    if (/^([A-Za-z]\w*(-[A-Za-z]\w+)*)\s*:\s*(.*)/) {
		## New item ...
		my ($item, $val) = ($1, $3);
		if ($lastitem) {
		    ## Try to store the last open line ...
		    if (exists $SECTION{$lastitem}) {
			print STDERR "ERROR($lc): ambiguous '$lastitem'".
				     " - skipping ...\n";
			next;
		    }
		    $SECTION{$lastitem} = $line;
		}
		$lastitem = lc $1; $line = $3;
	    }
	}
	close $cfh;
    }
    return ($err, undef) if ($err);
    if ($lastitem) {
	if (exists $SECTION{$lastitem}) {
	    print STDERR "ERROR($lc): ambiguous '$lastitem' - skipping ...\n";
	} else {
	    $SECTION{$lastitem} = $line;
	}
    }
    if (%SECTION) { ++$section; push @FILE, { %SECTION }; }
    %FILE = (); $item = 'source'; $lc = 0;
    for my $section (@FILE) {
	++$lc; $secname = $section->{$item};
	unless (defined ($secname)) {
	    print STDERR "ERROR: Section #$lc contains no identification!\n";
	    next;
	}
	if (exists $FILE{$secname}) {
	    print STDERR "ERROR: Section #${lc}'s identification".
			 " is ambiguous!\n";
	    next;
	}
	if ($item eq 'source') {
	    $FILE{source} = $section;
	} else {
	    $FILE{$secname} = $section;
	}
	$item = 'package';
    }
    +(0, { %FILE })
}

sub prompt :prototype($;&)
{
    my ($prompt, $check_answer) = @_;
    unless (defined $check_answer) {
	$check_answer = sub {
	    local $_ = shift;
	    s/^\s+//; s/\s+$//;
	    if (/^no?$/) {
		0
	    } elsif (/^(?:y(?:es)?|ok)$/) {
		1
	    } else {
		print STDERR
		      "** Please answer with one of n, no, y, yes, ok !\n\n";
		+()
	    }
	};
    }
    my $buffered = $|; $| = 0;
    my $res;
    for (;;) {
	print "$prompt ";
	chomp (my $ans = <stdin>); $ans =~ s/\r$//;
	unless (defined $ans) { print "<eof>\n"; last; }
	$res = &$check_answer ($ans);
	last if (defined $res);
    }
    $res
}

sub check_debrelease :prototype($) {
    (local $_) = @_;
    return $_ if (empty $_);
    unless (/^\d+(?:\.\d+)?(?:[+~][0-9A-Fa-f]+)?$/ or /^[0-9A-Fa-f]+$/) {
	print STDERR "** Wrong format. Please retry!\n\n";
	return;
    }
    $_
}

sub empty :prototype(\[$@%]) {
    (local $_) = @_;
    if (defined $_) {
	if (ref $_ eq 'HASH') {
	    return unless (%$_ == 0);
	} elsif (ref $_ eq 'ARRAY') {
	    return unless (@$_ == 0);
	} else { # ref $_ eq 'SCALAR' !!
	    return unless (length ($$_ // '') == 0);
	}
    }
    1
}

sub check_eof :prototype(;$_) {
    local $_ = (@_ > 0 ? $_[$[] : $_);
    return if (defined $_);
    print "End of file found in input ... bye.\n"; exit 0;
}
